var notWSClient=function(){"use strict";var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var e=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(e){!function(t){function s(){}var i=s.prototype,n=t.EventEmitter;function r(t,e){for(var s=t.length;s--;)if(t[s].listener===e)return s;return-1}function o(t){return function(){return this[t].apply(this,arguments)}}i.getListeners=function(t){var e,s,i=this._getEvents();if(t instanceof RegExp)for(s in e={},i)i.hasOwnProperty(s)&&t.test(s)&&(e[s]=i[s]);else e=i[t]||(i[t]=[]);return e},i.flattenListeners=function(t){var e,s=[];for(e=0;e<t.length;e+=1)s.push(t[e].listener);return s},i.getListenersAsObject=function(t){var e,s=this.getListeners(t);return s instanceof Array&&((e={})[t]=s),e||s},i.addListener=function(t,e){if(!function t(e){return"function"==typeof e||e instanceof RegExp||!(!e||"object"!=typeof e)&&t(e.listener)}(e))throw new TypeError("listener must be a function");var s,i=this.getListenersAsObject(t),n="object"==typeof e;for(s in i)i.hasOwnProperty(s)&&-1===r(i[s],e)&&i[s].push(n?e:{listener:e,once:!1});return this},i.on=o("addListener"),i.addOnceListener=function(t,e){return this.addListener(t,{listener:e,once:!0})},i.once=o("addOnceListener"),i.defineEvent=function(t){return this.getListeners(t),this},i.defineEvents=function(t){for(var e=0;e<t.length;e+=1)this.defineEvent(t[e]);return this},i.removeListener=function(t,e){var s,i,n=this.getListenersAsObject(t);for(i in n)n.hasOwnProperty(i)&&-1!==(s=r(n[i],e))&&n[i].splice(s,1);return this},i.off=o("removeListener"),i.addListeners=function(t,e){return this.manipulateListeners(!1,t,e)},i.removeListeners=function(t,e){return this.manipulateListeners(!0,t,e)},i.manipulateListeners=function(t,e,s){var i,n,r=t?this.removeListener:this.addListener,o=t?this.removeListeners:this.addListeners;if("object"!=typeof e||e instanceof RegExp)for(i=s.length;i--;)r.call(this,e,s[i]);else for(i in e)e.hasOwnProperty(i)&&(n=e[i])&&("function"==typeof n?r.call(this,i,n):o.call(this,i,n));return this},i.removeEvent=function(t){var e,s=typeof t,i=this._getEvents();if("string"===s)delete i[t];else if(t instanceof RegExp)for(e in i)i.hasOwnProperty(e)&&t.test(e)&&delete i[e];else delete this._events;return this},i.removeAllListeners=o("removeEvent"),i.emitEvent=function(t,e){var s,i,n,r,o=this.getListenersAsObject(t);for(r in o)if(o.hasOwnProperty(r))for(s=o[r].slice(0),n=0;n<s.length;n++)!0===(i=s[n]).once&&this.removeListener(t,i.listener),i.listener.apply(this,e||[])===this._getOnceReturnValue()&&this.removeListener(t,i.listener);return this},i.trigger=o("emitEvent"),i.emit=function(t){var e=Array.prototype.slice.call(arguments,1);return this.emitEvent(t,e)},i.setOnceReturnValue=function(t){return this._onceReturnValue=t,this},i._getOnceReturnValue=function(){return!this.hasOwnProperty("_onceReturnValue")||this._onceReturnValue},i._getEvents=function(){return this._events||(this._events={})},s.noConflict=function(){return t.EventEmitter=n,s},e.exports?e.exports=s:t.EventEmitter=s}("undefined"!=typeof window?window:t||{})}));let s={1e3:"Normal Closure",1001:"Going Away",1002:"Protocol Error",1003:"Unsupported Data",1005:"No Status Recvd",1006:"Abnormal Closure",1007:"Invalid frame payload data",1008:"Policy Violation",1009:"Message too big",1010:"Missing Extension",1011:"Internal Error",1012:"Service Restart",1013:"Try Again Later",1014:"Bad Gateway",1015:"TLS Handshake"};const i=Symbol("activity"),n=Symbol("state");let[,r]=location.hash.split("#");var o={ENV_TYPE:r,DEV_ENV:"development",STATE:{NOT_CONNECTED:0,CONNECTED:1,AUTHORIZED:2,NO_PING:3,ERRORED:4},STATE_NAME:{0:"Не подключен",1:"Подключен",2:"Авторизован",3:"Нет отклика",4:"Ошибка связи"},ACTIVITY:{IDLE:0,CONNECTING:1,CLOSING:2,TERMINATING:3,AUTHORIZING:4},ACTIVITY_NAME:{0:"Простаивает",1:"Открытие связи",2:"Закрытие связи",3:"Обрыв связи",4:"Авторизация"},WS_CLOSURE_REASONS:s,mapWsCloseCodes:function(t){if(!t)return"unknown reason";if(t.reason)return t.reason;let e=void 0!==t.code?t.code.toString():"undefined";return isNaN(parseInt(t))||(e=t),Object.prototype.hasOwnProperty.call(s,e)?s[e]:`Unknown reason: ${e}`},HEARTBEAT_INTERVAL:5e3,SYMBOL_ACTIVITY:i,SYMBOL_STATE:n,DEFAULT_SERVER_NAME:"not-ws server",DEFAULT_CLIENT_NAME:"not-ws link",ERR_MSG:{REQUEST_TIMEOUT:"Request timeout",MSG_ID_IS_NOT_VALID:"Message ID is not valid uuidv4",MSG_CREDENTIALS_IS_NOT_VALID:"Message Credentials is not valid!",MSG_TYPE_IS_NOT_VALID:"Message Type is not valid!",MSG_NAME_IS_NOT_VALID:"Message Name is not valid!"},PING_TIMEOUT:5e3,CLIENT_RECONNECT_TIMEOUT:5e3,CLIENT_RECONNECT_TIMEOUT_LONG:3e4,CLIENT_AUTO_RECONNECT:!0,TIME_OFFSET_REQUEST_INTERVAL:3e5,MSG_TYPE:{REQUEST:"request",RESPONSE:"response",EVENT:"event",COMMAND:"command"},TOKEN_TTL:1800,TOKEN_RENEW_TTL:300};var h,a={isFunc:function(t){return"function"==typeof t},isArray:function(t){return Array.isArray(t)},noop:function(){},heartbeat:function(){this._alive=!0},ObjHas:function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},tryParseJSON:function(t){try{let e=JSON.parse(t);if(e&&"object"==typeof e)return e}catch(t){console.error(t)}return!1},capitalizeFirstLetter:function(t){return t.charAt(0).toUpperCase()+t.slice(1)}};class c extends e{constructor({name:t,routes:e={},logger:s}){return super(),this.__name=t||"notWSRouter",this.logMsg=s?s.log:()=>{},this.logDebug=s?s.debug:()=>{},this.logError=s?s.error:()=>{},this.routes={__service:{updateToken:()=>(this.emit("updateToken"),Promise.resolve())},test:{sayHello:()=>(this.logMsg("Say hello for test route!"),Promise.resolve(!0))},request:{auth:()=>{this.logMsg("request.auth")}}},e&&Object.keys(e).length>0&&this.initRoutes(e),this}initRoutes(t){for(let e in t)this.setRoutesForType(e,t[e])}route({type:t,name:e,cred:s},i,n){if(a.ObjHas(this.routes,t)&&a.ObjHas(this.routes[t],e))return this.logMsg("ip:",n.getIP(),t,e),this.routes[t][e]({data:i,cred:s,client:n});throw new Error(`Route not found ${t}/${e}`)}setRoutesForType(t,e){return this.validateType(t),this.validateRoutes(e),a.ObjHas(this.routes,t)?this.routes[t]=Object.assign(this.routes[t],e):this.routes[t]=e,this}unsetRoutesForType(t,e=[]){if(this.validateType(t),this.validateRoutesList(e),a.ObjHas(this.routes,t)){for(let s of e)a.ObjHas(this.routes[t],s)&&delete this.routes[t][s];0===Object.keys(this.routes[t]).length&&delete this.routes[t]}return this}validateType(t){if("string"!=typeof t||""===t)throw new Error("Route's type name should be a String!");return!0}validateRoutes(t){if("object"!=typeof t||null==t)throw new Error("Route's type's routes set should be an Object!");return!0}validateRoutesList(t){if(!Array.isArray(t)||void 0===t)throw new Error("List of routes names should be an Array!");return!0}getRoutes(){return this.routes}}var u=new Uint8Array(16);function l(){if(!h&&!(h="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return h(u)}var T=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function E(t){return"string"==typeof t&&T.test(t)}for(var d=[],p=0;p<256;++p)d.push((p+256).toString(16).substr(1));function g(t,e,s){var i=(t=t||{}).random||(t.rng||l)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,e){s=s||0;for(var n=0;n<16;++n)e[s+n]=i[n];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=(d[t[e+0]]+d[t[e+1]]+d[t[e+2]]+d[t[e+3]]+"-"+d[t[e+4]]+d[t[e+5]]+"-"+d[t[e+6]]+d[t[e+7]]+"-"+d[t[e+8]]+d[t[e+9]]+"-"+d[t[e+10]]+d[t[e+11]]+d[t[e+12]]+d[t[e+13]]+d[t[e+14]]+d[t[e+15]]).toLowerCase();if(!E(s))throw TypeError("Stringified UUID is invalid");return s}(i)}const f={validateType:!0,validateTypeAndName:!0,secure:!1,securityException:["request.auth"],validators:{},types:{typeOfMessage:["list","of","name's","of","actions"],test:["sayHello"],__service:["updateToken"]}};class v extends e{constructor(t={}){return super(),this.options=Object.assign({},f,t),a.ObjHas(this.options.types,o.MSG_TYPE.REQUEST)&&!a.ObjHas(this.options.types,o.MSG_TYPE.RESPONSE)&&(this.options.types[o.MSG_TYPE.RESPONSE]=this.options.types[o.MSG_TYPE.REQUEST]),this}setCredentials(t){return this.options.credentials=t,this}getServiceData(t){return a.ObjHas(t,"service")?t.service:{id:t.id,time:t.time,type:t.type,name:t.name}}getType(t){return t.type}getName(t){return t.name}getCredentials(t){return t.cred}getPayload(t){return t.payload}isErrored(t){return void 0!==t.error&&null!==t.error}getErrorMessage(t){if("string"==typeof t.error)return t.error;if("object"==typeof t.error)return`${t.error.code}: ${t.error.message}`;throw new Error("No error data in message")}getErrorReport(t){return t.error}pack(t,e,s){if(null==e)throw new Error("No Service Data for packing notWSMsg");let i={id:g(),time:(new Date).getTime(),payload:t};return this.options.credentials&&(i.cred=this.options.credentials),s&&(i.error=s),Object.assign(i,e)}unpack(t){if(this.isErrored(t)){let e=new Error(this.getErrorMessage(t));throw e.report=this.getErrorReport(t),e}return{cred:this.getCredentials(t),service:this.getServiceData(t),payload:this.getPayload(t)}}validateCredentials(t={},e){return this.options.validators&&this.options.validators.credentials?this.options.validators.credentials(t,e):!this.options.secure}validateType(t){return!!this.options.types&&Object.keys(this.options.types).indexOf(t)>-1}validateTypeAndName(t,e){return!(!this.options.types||!a.ObjHas(this.options.types,t))&&this.options.types[t].indexOf(e)>-1}routeIsSecurityException(t,e){let s=`${t}.${e}`;return!(!this.options.securityException||!Array.isArray(this.options.securityException))&&this.options.securityException.indexOf(s)>-1}validate(t){let e=this.getServiceData(t);if(!E(e.id))throw new Error(o.ERR_MSG.MSG_ID_IS_NOT_VALID);if(!this.routeIsSecurityException(e.type,e.name)&&!this.validateCredentials(this.getCredentials(t),e))throw new Error(o.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID);return this.validateRouteTypeAndName(t),t}validateRouteTypeAndName(t){if(this.options.validateTypeAndName){this.validateRouteType(t);let e=this.getType(t),s=this.getName(t);if(!this.validateTypeAndName(e,s)){let t=new Error(o.ERR_MSG.MSG_NAME_IS_NOT_VALID);throw t.details={type:e,name:s},t}}else this.validateRouteType(t)}validateRouteType(t){let e=this.getType(t);if(this.options.validateType&&!this.validateType(e)){let t=new Error(o.ERR_MSG.MSG_TYPE_IS_NOT_VALID);throw t.details={type:e},t}}enableRoute(t,e){return a.ObjHas(this.options,"types")||(this.options.types={}),a.ObjHas(this.options.types,t)||(this.options.types[t]=[]),-1===this.options.types[t].indexOf(e)&&this.options.types[t].push(e),this}disableRoute(t,e){return a.ObjHas(this.options,"types")&&a.ObjHas(this.options.types,t)?(this.options.types[t].indexOf(e)>-1&&this.options.types[t].splice(this.options.types[t].indexOf(e),1),this):this}}const m=Symbol("activity"),I=Symbol("state"),y=40,O={secure:!0,reconnect:!0,ping:!0,count:!0};class A extends e{constructor(t,e=!1){return super(),this.options=Object.assign({},O,t),this.options.ws?(this.ws=t.ws,delete t.ws,1===this.ws.readyState?(this.setAlive(),this[I]=o.STATE.CONNECTED,this.options.secure&&(this[I]=o.STATE.AUTHORIZED)):(this[I]=o.STATE.NOT_CONNECTED,this.setDead())):(this[I]=o.STATE.NOT_CONNECTED,this.setDead(),this.ws=null),this[m]=o.ACTIVITY.IDLE,this.isTerminated=!1,this.isReconnecting=!1,this.closing=!1,this.slave=e,this.heartbeatTimeout=null,this.connectInterval=null,this.connCount=0,this.connCountMax=10,this.errConnMsg=null,this.firstConn=!0,this.bindEnvEvents(),this.bindSocketEvents(),this.history=[],this.passed={in:0,out:0},this}getStatus(){return{state:o.STATE_NAME[this[I]],activity:o.ACTIVITY_NAME[this[m]],isAlive:this.isAlive(),isTerminated:this.isTerminated,isReconnecting:this.isReconnecting,in:this.passed.in,out:this.paased.out}}getSocket(){return this.ws}getIP(){return!!(this.isOpen()&&this.ws._socket&&this.ws._socket.remoteAddress)&&this.ws._socket.remoteAddress}bindSocketEvents(){this.ws&&(this.listeners={open:this.onOpen.bind(this),message:this.onMessage.bind(this),close:this.onClose.bind(this),error:this.onError.bind(this)},this.ws.onopen=this.listeners.open,this.ws.onmessage=this.listeners.message,this.ws.onclose=this.listeners.close,this.ws.onerror=this.listeners.error)}bindEnvEvents(){window.onunload=this.disconnect.bind(this),window.onbeforeunload=this.disconnect.bind(this)}disconnect(){this.emit("diconnecting"),this.ws&&(this.ws.onclose=a.noop,this.ws.onerror=a.noop,this.ws.onmessage=a.noop,this.ws.onopen=a.noop,this.ws.close&&this.ws.close(),this.terminate())}terminate(){this.connectInterval&&clearInterval(this.connectInterval),this.ws&&(this.activity=o.ACTIVITY.TERMINATING,this.ws.terminate&&this.ws.terminate()),this.isTerminated=!0,this.ws=null,this.state!==o.STATE.NOT_CONNECTED&&(this.state=o.STATE.NOT_CONNECTED),this.setDead()}async connect(){try{this.ws&&this.ws.readyState!==WebSocket.CLOSED&&this.disconnect(),this.setAlive(),this.isTerminated=!1,this.connCount++;let t=this.getConnectURI();this.emit("connectURI",t),this.activity=o.ACTIVITY.CONNECTING,this.ws=new WebSocket(t),this.bindSocketEvents()}catch(t){this.emit("error",t),this.scheduleReconnect()}}setHalfDead(){this._alive?this._alive=!1:this.setDead()}setAlive(){this._alive=!0,this.alive=!0}setDead(){this.alive=!1}isAlive(){return this.alive}isDead(){return!this.alive}getConnectURI(){let t="ws";this.options.protocol?t=this.options.protocol:this.options.ssl&&(t="wss");let e=`${t}://${this.options.host}`;return e=this.options.port&&80!==parseInt(this.options.port)?`${e}:${this.options.port}/${this.options.path}`:`${e}/${this.options.path}`,this.isSecure()?`${e}?token=${this.jwtToken}`:e}setToken(t){this.jwtToken=t}onOpen(){this.connCount=0,this.setAlive(),clearInterval(this.connectInterval),this.connectInterval=!1,this.errConnMsg=null,this.state=o.STATE.CONNECTED,this.isSecure()&&(this.state=o.STATE.AUTHORIZED),this.initPing(),this.emit("ready"),this.sendAllFromHistory()}onMessage(t){try{this.countPassed(t,"in");let e=t.data;if(this.checkPingMsg(e))return;let s=a.tryParseJSON(e);if(!s)return void this.emit("messageInWronFormat",e);this.emit("message",s)}catch(t){this.emit("error",t)}}onError(t){this.connectInterval&&(clearInterval(this.connectInterval),this.connectInterval=!1),this.activity===o.ACTIVITY.TERMINATING?this.state=o.STATE.NOT_CONNECTED:this.state=o.STATE.ERRORED,this.emit("error",t)}onClose(t){if(void 0!==t.code){let e=`${t.code}::`+o.mapWsCloseCodes(t);this.emit("close",e)}else isNaN(t)?this.emit("close",t):this.emit("terminated",o.mapWsCloseCodes(t));this.activity===o.ACTIVITY.CLOSING?this.state=o.STATE.NOT_CONNECTED:this.state=o.STATE.ERRORED}suicide(){this.emit("errored",this)}getReconnectTimeout(){return this.connCount>=this.connCountMax?o.CLIENT_RECONNECT_TIMEOUT_LONG:o.CLIENT_RECONNECT_TIMEOUT}scheduleReconnect(){if(!this.slave){let t=this.getReconnectTimeout();this.emit("reconnectiningEvery",t),this.connectInterval&&clearInterval(this.connectInterval),this.connectInterval=setInterval(this.performReconnect.bind(this),t)}}performReconnect(){this.ws&&this.ws.readyState!==this.ws.CLOSED||this.connect()}reconnect(){if(!this.slave){if([o.ACTIVITY.CONNECTING].indexOf(this.activity)>-1)return void this.emit("concurentActivity",o.ACTIVITY[this.activity]);this.scheduleReconnect()}}isSecure(){return this.options.secure}isAutoReconnect(){return!this.slave&&(void 0!==this.options.reconnect?this.options.reconnect:o.CLIENT_AUTO_RECONNECT)}isConnected(t=!0){return!(!this.ws||!this.isAlive())&&(!t||this.isConnectionSecure())}isConnectionSecure(){let t=o.STATE.CONNECTED;return this.isSecure()&&(t=o.STATE.AUTHORIZED),this.state===t&&1===this.ws.readyState}isOpen(){return this.ws&&1===this.ws.readyState}isMessageTokenUpdateRequest(t){return"__service"===t.type&&"updateToken"===t.name}initPing(){this.slave?this.on("pong",a.heartbeat):this.options.ping&&(this.pingInterval&&(clearInterval(this.pingInterval),this.pingInterval=!1),this.pingInterval=setInterval(this.sendPing.bind(this),this.options.pingTimeout||o.PING_TIMEOUT))}sendPing(){if(!this.isAlive())return this.emit("noPong"),void(this.state===o.STATE.CONNECTED&&(this.state=o.STATE.NOT_CONNECTED));this.setHalfDead(),this.ping()}pong(){this.isOpen()&&(this.wsSend("pong"),this.emit("pong"))}ping(){this.isOpen()&&(this.wsSend("ping").catch(a.noop),this.emit("ping"))}checkPingMsg(t){return"ping"===t?(this.setAlive(),this.emit("pinged"),this.pong(),!0):"pong"===t&&(this.setAlive(),this.emit("ponged"),!0)}async send(t,e){try{this.isConnected(e)||this.isOpen()&&this.isMessageTokenUpdateRequest(t)?await this.wsSend(JSON.stringify(t)):(this.emit("messageNotSent",o.STATE_NAME[this.state]),this.addToHistory(t))}catch(t){throw this.state=o.STATE.ERRORED,t}}addToHistory(t){this.emit("addToHistory",t),this.history.push(t),this.history.length>y&&this.history.shift()}sendAllFromHistory(){for(;this.history.length;){let t=this.history.shift();this.send(t,!0).catch(this.onError.bind(this))}}get state(){return this[I]}set state(t=o.STATE.NOT_CONNECTED){if(!(Object.values(o.STATE).indexOf(t)>-1))throw new Error("set: Unknown notWSServerClient state: "+t);switch(this.emit("stateChange",t,o.STATE_NAME[t]),this[I]){case o.STATE.NOT_CONNECTED:if(!([o.STATE.CONNECTED,o.STATE.ERRORED].indexOf(t)>-1))throw new Error("Wrong state transition: "+o.STATE_NAME[this[I]]+" -> "+o.STATE_NAME[t]);this[I]=t,this.activity=o.ACTIVITY.IDLE;break;case o.STATE.CONNECTED:if(!([o.STATE.AUTHORIZED,o.STATE.NO_PING,o.STATE.ERRORED,o.STATE.NOT_CONNECTED].indexOf(t)>-1))throw new Error("Wrong state transition: "+o.STATE_NAME[this[I]]+" -> "+o.STATE_NAME[t]);this[I]=t,this.activity=o.ACTIVITY.IDLE;break;case o.STATE.AUTHORIZED:if(!([o.STATE.CONNECTED,o.STATE.NO_PING,o.STATE.ERRORED,o.STATE.NOT_CONNECTED].indexOf(t)>-1))throw new Error("Wrong state transition: "+o.STATE_NAME[this[I]]+" -> "+o.STATE_NAME[t]);this[I]=t,this.activity=o.ACTIVITY.IDLE;break;case o.STATE.NO_PING:if(!([o.STATE.NOT_CONNECTED].indexOf(t)>-1))throw new Error("Wrong state transition: "+o.STATE_NAME[this[I]]+" -> "+o.STATE_NAME[t]);this[I]=t,this.activity=o.ACTIVITY.IDLE;break;case o.STATE.ERRORED:if(!([o.STATE.NOT_CONNECTED,o.STATE.ERRORED].indexOf(t)>-1))throw new Error("Wrong state transition: "+o.STATE_NAME[this[I]]+" -> "+o.STATE_NAME[t]);this[I]=t,this.activity=o.ACTIVITY.IDLE}switch(this[I]){case o.STATE.NOT_CONNECTED:this.emit("disconnected"),this.isAlive()?(this.emit("beforeReconnect"),this.reconnect()):this.isAutoReconnect()&&this.scheduleReconnect();break;case o.STATE.CONNECTED:this.emit("connected");break;case o.STATE.AUTHORIZED:this.emit("authorized");break;case o.STATE.NO_PING:this.emit("noPing"),this.disconnectTimeout=setTimeout(this.disconnect.bind(this),100);break;case o.STATE.ERRORED:this.emit("errored"),this.disconnectTimeout=setTimeout(this.disconnect.bind(this),100)}}get activity(){return this[m]}set activity(t=o.ACTIVITY.IDLE){if(!(Object.values(o.ACTIVITY).indexOf(t)>-1))throw new Error("set: Unknown notWSServerClient activity: "+t);switch(this.emit("changeActivity",t,o.ACTIVITY_NAME[t]),this[m]){case o.ACTIVITY.IDLE:[o.ACTIVITY.CONNECTING,o.ACTIVITY.CLOSING,o.ACTIVITY.TERMINATING,o.ACTIVITY.AUTHORIZING].indexOf(t)>-1&&(this[m]=t);break;case o.ACTIVITY.CONNECTING:case o.ACTIVITY.CLOSING:case o.ACTIVITY.TERMINATING:case o.ACTIVITY.AUTHORIZING:[o.ACTIVITY.IDLE].indexOf(t)>-1&&(this[m]=t)}switch(this[m]){case o.ACTIVITY.IDLE:this.emit("idle",this);break;case o.ACTIVITY.CONNECTING:this.emit("connecting",this);break;case o.ACTIVITY.AUTHORIZING:this.emit("authorizing",this);break;case o.ACTIVITY.CLOSING:this.emit("closing",this);break;case o.ACTIVITY.TERMINATING:this.emit("terminating",this)}}wsSend(t){return new Promise((e,s)=>{this.ws.send(this.countPassed(t,"out"),t=>{t?s(t):e()})})}countPassed(t,e){return this.passed[e]+=this.options.count?this.getMessageSize(t):0,t}getMessageSize(t){return new Blob([t]).size}destroy(){clearInterval(this.connectInterval),clearInterval(this.pingInterval),clearTimeout(this.disconnectTimeout),this.emit("destroyed"),this.removeAllListeners()}}return class extends e{constructor({name:t,connection:e,getToken:s,messenger:i,router:n,logger:r,identity:h,credentials:a,slave:u=!1,debug:l=[]}){if(!n)throw new Error("Router is not set or is not instance of notWSRouter");if(n instanceof c||(n=new c(n)),!i)throw new Error("Messenger is not set or is not instance of notWSMessenger");return i instanceof v||(i=new v(i)),super(),this.__name=t||o.DEFAULT_CLIENT_NAME,this.jwtToken=null,this.jwtExpire=null,this.jwtDate=null,this.tokenGetter=s,this.identity=h,this.credentials=a,this.messenger=i,this.router=n,this.slave=u,this.debug=l,this.initConnection(e,this.slave),this.slave||this.router.on("updateToken",this.renewToken.bind(this)),this.logMsg=r?r.log:()=>{},this.logDebug=r?r.debug:()=>{},this.logError=r?r.error:()=>{},this.requests=[],this.reqTimeout=15e3,this.reqChkTimer=null,this.reqChkStep=2e3,this._timeOffset=0,this.getTimeOffsetInt=null,this.slave||this.connect(),this}getIP(){return!!this.connection&&this.connection.getIP()}initConnection(t){this.connection=new A(t),this.connection.on("disconnected",()=>{this.logMsg("disconnected"),this.stopReqChckTimer(),this.emit("close",this),this.emit("disconnected",this)}),this.connection.on("connected",()=>{this.logMsg("connected"),this.startReqChckTimer(),this.emit("open",this),this.emit("connected",this)}),this.connection.on("connectURI",t=>{this.logMsg("connectURI",t)}),this.connection.on("close",t=>{this.logMsg("close",t)}),this.connection.on("error",t=>{this.logError(t)}),this.connection.on("message",this.processMessage.bind(this)),this.connection.on("ready",()=>{this.logMsg("ready"),this.emit("ready",this)}),this.connect.debug&&this.connect.debug.includes("ping")&&(this.connection.on("ping",()=>{this.logDebug("ping")}),this.connection.on("pong",()=>{this.logDebug("pong")}),this.connection.on("pinged",()=>{this.logDebug("pinged")}),this.connection.on("ponged",()=>{this.logDebug("ponged")}))}async connect(){if(!this.slave)try{this.isConnected()||(this.connection.isSecure()&&this.saveToken(await this.getToken()),this.connection.connect())}catch(t){this.logError(t)}}suicide(){this.emit("errored",this)}disconnect(){this.connection.disconnect()}terminate(){this.connection.terminate(),this.connection.destroy()}destroy(){clearInterval(this.getTimeOffsetInt),this.emit("destroyed"),this.removeAllListeners()}isDead(){return!this.connection.isAlive()}isAlive(){return this.connection.isAlive()}reconnect(){this.connection.reconnect()}isConnected(t=!0){return this.connection.isConnected(t)}isSecure(){return this.connection.isSecure()}isAutoReconnect(){return this.connection.isAutoReconnect()}startReqChckTimer(){clearTimeout(this.reqChkTimer),this.reqChkTimer=setTimeout(this.checkRequests.bind(this),this.reqChkStep)}stopReqChckTimer(){clearTimeout(this.reqChkTimer)}findRequest(t){for(let e=0;e<this.requests.length;e++)if(this.requests[e].id===t)return e;return!1}fullfillRequest(t){let e=this.findRequest(t);if(!1===e)return this.logMsg(`failed to find request for response ${t}`),null;let s=this.requests[e];return this.requests.splice(e,1),a.isFunc(s.cb)?s:null}addRequest(t,e){this.requests.push({id:t,time:Date.now(),cb:e})}checkRequests(){let t=[],e=Date.now();this.requests.forEach(s=>{e-s.time>this.reqTimeout&&t.push(s.id)}),t.forEach(t=>{let e=this.findRequest(t);if(!1===e)return void this.logMsg(`timeout check:failed to find request for response ${t}`);let s=this.requests[e];a.isFunc(s.cb)?s.cb(o.ERR_MSG.REQUEST_TIMEOUT):this.logMsg(`timeout check:Не задан callback для запроса с id: ${t}`),this.requests.splice(e,1)})}getToken(t=!1){let e=localStorage.getItem("token");return void 0!==e&&"undefined"!==e&&e&&!t?Promise.resolve(e):a.isFunc(this.tokenGetter)?this.tokenGetter():Promise.reject()}async renewToken(){if(!this.slave)try{let t=await this.getToken(!0);if(!t)throw new Error("Token isn't renewed");this.saveToken(t)}catch(t){this.logError(t)}}saveToken(t){this.slave||(localStorage.setItem("token",t),this.jwtToken=t,this.messenger.setCredentials(t),this.connection.setToken(t),this.emit("tokenUpdated",t))}ping(){this.connection.sendPing()}processMessage(t){try{this.messenger.validate(t);let e=this.messenger.unpack(t);this.emit("message",e,this),this.emit(e.service.type+":"+e.service.name,e.service,e.payload,this.connection.getSocket()),this.selectRoute(e)}catch(t){this.logError(t,t.details)}}selectRoute(t){switch(t.service.type){case o.MSG_TYPE.RESPONSE:this.routeResponse(t);break;case o.MSG_TYPE.REQUEST:this.routeRequest(t);break;case o.MSG_TYPE.EVENT:this.routeEvent(t);break;default:this.routeCommon(t)}}routeResponse(t){let e=this.fullfillRequest(t.service.id);null!==e&&e.cb(t)}routeEvent(t){this.router.route(t.service,t.payload,this).catch(t=>{this.logError(t)})}routeCommon(t){this.router.route(t.service,t.payload,this).catch(e=>{this.logError(e),this.respond({},{id:t.service.id,type:o.MSG_TYPE.RESPONSE,name:t.service.name},e)})}routeRequest(t){this.router.route(t.service,t.payload,this).then(e=>{this.respond(e,{id:t.service.id,type:o.MSG_TYPE.RESPONSE,name:t.service.name})}).catch(e=>{this.logError(e),this.respond({},{id:t.service.id,type:o.MSG_TYPE.RESPONSE,name:t.service.name},e)})}send(t,e,s){return t===o.MSG_TYPE.REQUEST?this.request(e,s):this.message(t,e,s)}respond(t,e={},s){if("object"==typeof t&&null!==t){let i=this.messenger.pack(t,e,s);return this.connection.send(i)}return!0}__request(t,e,s,i=!0){let n=this.messenger.pack(e,{type:o.MSG_TYPE.REQUEST,timeOffset:this.timeOffset,name:t});this.addRequest(this.messenger.getServiceData(n).id,s),this.connection.send(n,i).catch(this.logError.bind(this))}request(t,e,s=!0){return new Promise((i,n)=>{try{this.__request(t,e,t=>t===o.ERR_MSG.REQUEST_TIMEOUT_MESSAGE?n(t):this.messenger.isErrored(t)?n(t):void i(t),s)}catch(t){n(t)}})}message(t,e,s){"pong"!==s&&"ping"!==s&&this.logDebug("outgoing message",t,e);let i=this.messenger.pack(s,{type:t,timeOffset:this.timeOffset,name:e});return this.connection.send(i).catch(this.logError.bind(this))}informClientAboutExperiedToken(){this.logMsg("force to update token"),this.send("__service","updateToken",{},!1).catch(this.logError.bind(this))}requestServerTime(){if(this.connection.isConnected()){const t=Date.now();this.request("getTime",{}).then(e=>{const s=Date.now(),i=Math.round((s-t)/2),n=parseInt(e,10)+i-s;this.timeOffset=n}).catch(t=>{this.logError(t)})}}set timeOffset(t){this._timeOffset=t}get timeOffset(){return this._timeOffset}getTimeOnAuthorized(){this.getTimeOffsetInt&&(clearInterval(this.getTimeOffsetInt),this.getTimeOffsetInt=null),this.requestServerTime(),this.getTimeOffsetInt=setInterval(this.requestServerTime.bind(this),o.TIME_OFFSET_REQUEST_INTERVAL)}}}();
