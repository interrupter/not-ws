/**
*
* Client - main function is to connect and handle requests from/to server.
*
* Options
* @params {string}          name              - client name, optional. default: WSCLient
* @params {object}          connection        - object describing server and behaviour of this client
*         {string}            host            - server address
*         {string}            port            - server port
*         {string}            path            - path on server
*         {string}            protocol        - connection protocol, preffered over 'ssl' option
*         {boolean}           ssl             - user ssl encryption for connection
*         {boolean}           secure          - auth needed
*         {boolean}           reconnect       - reconnect if disconnected
*         {boolean}           ping            - ping server to indentify connection problems ASAP
* @params {function}        getToken          - should return token for auth on server
* @params {notWSMessenger}  messenger         - message handler
* @params {notWSRouter}     router            - request handler
* @params {object}          logger            - log interface {function:log, function:debug, function:error}
*
**/

class notWSClient extends EventEmitter{
  constructor({
    name,
    connection,
    getToken,
    messenger,
    router,
    logger,
    identity,					//user information
		credentials			  //client creds for access
  }){
    if(!router || !(router instanceof notWSRouter)){
      throw new Error('Router is not set or is not instance of notWSRouter');
    }
    if(!messenger || !(messenger instanceof notWSMessenger)){
      throw new Error('Messenger is not set or is not instance of notWSMessenger');
    }
    super();
    //Основные параметры
    this.__name = name ? name : CONST.DEFAULT_CLIENT_NAME;
    //jwt
    this.jwtToken = null; //Токен авторизации.
    this.jwtExpire = null; //Время до истечения токена.
    this.jwtDate = null; //Дата создания токена.
    //setting envs
    this.tokenGetter = getToken;
    this.identity = identity;
		this.credentials = credentials;
    this.messenger = messenger;
    this.router =   router;
    //Подключение к WS
    this.initConnection(connection);
    this.router.on('updateToken', this.renewToken.bind(this));
    //common constructor part for client browser client, node client, node server client
    <%- include('./client.common.constructor.ejs') %>
    this.connect();
    return this;
  }

  initConnection(connection){
    this.connection = new notWSConnection(connection);
    this.connection.on('disconnected', ()=>{
      this.logMsg('dicconnected');
      this.stopReqChckTimer();
      this.emit('close', this);
    });
    this.connection.on('connected', ()=>{
      this.logMsg('connected');
      //Запускаем таймер проверки списка запросов.
      this.startReqChckTimer();
      this.emit('open', this);
    });
    this.connection.on('connectURI', (e)=>{this.logMsg('connectURI', e);});
    this.connection.on('close', (e)=>{this.logMsg('close', e);});
    this.connection.on('error', (e)=>{
      this.logError(e);
    });
    this.connection.on('message', this.processMessage.bind(this));

    this.connection.on('ready', ()=>{
      this.logMsg('ready');
      this.emit('ready', this);
    });
  }

  async connect(){
    try{
      if(!this.isConnected()){
        //если нужна аутентификация
        if(this.connection.isSecure()){
          //получаем и сохраняем токен токен
          this.saveToken(await this.getToken());
        }
        //подключаемся
        this.connection.connect();
      }
    }catch(e){
      this.logError(e);
    }
  }

  disconnect(){
    this.connection.disconnect();
  }

  terminate(){
    this.connection.terminate();
  }

  reconnect(){
    this.connection.reconnect();
  }

  //Получение токена.
  //Возможно реализовать разными способами, поэтому выделено в отдельный метод.
  getToken(<% if (env !== 'node'){ %>renew = false<% } %>){
    <% if (env !== 'node'){ %>
    let token = localStorage.getItem('token');
    if((typeof token !== 'undefined') && (token !== 'undefined') && token && !renew){
      return Promise.resolve(token);
    }else{
    <% } %>
      if(Func.isFunc(this.tokenGetter)){
        return this.tokenGetter();
      }else{
        return Promise.reject();
      }
    <% if (env !== 'node') { %>
    }
    <% } %>
  }

  async renewToken(){
    try{
      let token = await this.getToken(true);
      if(token){
        this.saveToken(token);
      }else{
        throw new Error('Token isn\'t renewed');
      }
    }catch(e){
      this.logError(e);
    }
  }

  saveToken(token){
    <% if (env !== 'node'){ %>
    localStorage.setItem('token', token);
    <% } %>
    this.jwtToken = token;
    this.messenger.setCredentials(token);
    this.connection.setToken(token);
    this.emit('tokenUpdated', token);
  }

  //Обработчик сообщений пришедших от сервера.
  //data - JSON
  processMessage(data){
    try{
      this.messenger.validate(data);
      let msg = this.messenger.unpack(data);
      //general event
      this.emit('message', msg, this);
      //specific event
      this.emit(msg.service.type + ':' + msg.service.name, msg.service, msg.payload, this.connection.getSocket());
      //routing
      this.selectRoute(msg);
    }catch(e){
      this.logError(e, e.details);
      <% if (env === 'node'){ %>
      if(e.message === CONST.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID){
				this.informClientAboutExperiedToken();
			}
      <% } %>
    }
  }

  selectRoute(msg){
		switch(msg.service.type){
		//couple of special types
		case CONST.MSG_TYPE.RESPONSE: this.routeResponse(msg);  break;
		case CONST.MSG_TYPE.REQUEST: 	this.routeRequest(msg);  break;
		case CONST.MSG_TYPE.EVENT:    this.routeEvent(msg);     break;
			//all other
		default:                      this.routeCommon(msg);
		}
	}

	routeResponse(msg){
		let request = this.fullfillRequest(msg.service.id);
		if(request !== null){
			request.cb(msg);
		}
	}

	routeEvent(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.catch((e)=>{
				this.logError(e);
			});
	}

	routeCommon(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.catch((e)=>{
				this.logError(e);
				this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
			});
	}

	routeRequest(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.then((responseData)=>{
				this.respond(responseData, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name});
			})
			.catch((e)=>{
				this.logError(e);
				this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
			});
	}

  respond(resp, service = {}, error){
    if(resp && typeof resp === 'object' && resp !== null){
      let msg = this.messenger.pack(resp, service, error);
      return this.connection.send(msg);
    }else{
      return true;
    }
  }

  /**
  *  Отправка данных определенного типа и названия
  *  @param {string}  type  тип данных
  *  @param {string}  name  название
  *  @param {object}  payload  данные
  *  @returns  {Promise}
  */
  send(type, name, payload){
    if(type === CONST.MSG_TYPE.REQUEST){
      return this.request(name, payload);
    }else{
      return this.message(type, name, payload);
    }
  }

  message(type, name, payload){
    if((payload!== 'pong') && ( payload!== 'ping')){
      this.logMsg('outgoing message', type, name);
    }
    let message = this.messenger.pack(payload, {
      type,
      timeOffset: this.timeOffset,
      name,
    });
    return this.connection.send(message).catch(this.logError.bind(this));
  }

  //Отправка запроса на сервер.
  request(name, payload){
    this.logMsg('outgoing request', name);
    return new Promise((res, rej)=>{
      try{
        //Формирование данных запроса.
        let req = this.messenger.pack(payload, {
          type:       'request',
          timeOffset: this.timeOffset,
          name,
        });
        //Добавление запроса в список отправленных запросов.
        this.addRequest(this.messenger.getServiceData(req).id, res);
        //Отправка запроса на сервер.
        this.connection.send(req);
      }catch(e){
        this.logError(e);
        rej(e);
      }
    });
  }

  isSecure() {
    return this.connection.isSecure();
  }

  isConnected(){
    return this.connection.isConnected();
  }

  isDead() {
		return !this.connection.isAlive();
	}

  isAlive() {
		return this.connection.isAlive();
	}

  isAutoReconnect(){
    return this.connection.isAutoReconnect();
  }

  /**
  * Server time
  */
  requestServerTime() {
    if (this.connection.isConnected()) {
      let req = {
        cmd: 'getTime',
        data: {}
      };
      const sendTime = Date.now();
      this.request(req, (err, result) => {
        if (err) {
          this.logError(err);
        } else {
          const receiveTime = Date.now();
          const correction = Math.round((receiveTime - sendTime) / 2);
          const serverTime = parseInt(result, 10);
          const correctedTime = serverTime + correction;
          const offset = correctedTime - receiveTime;
          this.timeOffset = offset;
        }
      });
    }
  }

  set timeOffset(val) {
    this._timeOffset = val;
  }

  get timeOffset() {
    return this._timeOffset;
  }

  getTimeOnAuthorized(){
    if (this.getTimeOffsetInt) {
      clearInterval(this.getTimeOffsetInt);
      this.getTimeOffsetInt = null;
    }
    this.requestServerTime();
    this.getTimeOffsetInt = setInterval(this.requestServerTime.bind(this), CONST.TIME_OFFSET_REQUEST_INTERVAL);
  }

  //набор методов для работы с запросами и выявления безответных
  <%- include('./client.common.requests.ejs'); %>
}
