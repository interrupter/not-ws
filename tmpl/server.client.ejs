const EventEmitter = require('events');
const JWT = require('jsonwebtoken');
const CONST = require('./const.js');
const Func = require('./func.js');

const notWSRouter = require('./router.js');
const notWSMessenger = require('./messenger.js');
const notWSConnection = require('./connection.js');

/**
 *  Инкапсулирует обработку соединения пользователя
 *
 **/

class notWSServerClient extends EventEmitter {
	constructor({
		name,
    connection,				//{ ws, ip, secure }
		messenger, 				//экземпляр notWSMessage подобного класса, с упаковщиками нужного типа,
		router,
		logger,
    identity,					//user information
		credentials			  //client creds for access
	}) {
    if(!router || !(router instanceof notWSRouter)){
      throw new Error('Router is not set or is not instance of notWSRouter');
    }
    if(!messenger || !(messenger instanceof notWSMessenger)){
      throw new Error('Messenger is not set or is not instance of notWSMessenger');
    }
		super();
		//basic params
		this.__name = name ? name : CONST.DEFAULT_CLIENT_NAME;
    //jwt
    this.jwtToken = null; //Токен авторизации.
    this.jwtExpire = null; //Время до истечения токена.
    this.jwtDate = null; //Дата создания токена.
    //setting envs
		this.identity = identity;
		this.credentials = credentials;
    this.messenger = messenger;
		this.router = router;
    //Подключение к WS
		this.initConnection(connection);
    this.router.on('updateToken', this.renewToken.bind(this));
		//common constructor part for client browser client, node client, node server client
		<%- include('./client.common.constructor.ejs'); %>
    this.connect();
		return this;
	}

  initConnection(connection){
    this.connection = new notWSConnection(connection);
    this.connection.on('disconnected', ()=>{
      this.logMsg('dicconnected');
      this.stopReqChckTimer();
      this.emit('close', this);
    });
    this.connection.on('connected', ()=>{
      this.logMsg('connected');
      //Запускаем таймер проверки списка запросов.
      this.startReqChckTimer();
      this.emit('open', this);
    });
    this.connection.on('connectURI', (e)=>{this.logMsg('connectURI', e);});
    this.connection.on('close', (e)=>{this.logMsg('close', e);});
    this.connection.on('error', (e)=>{
      this.logError(e);
    });
    this.connection.on('message', this.processMessage.bind(this));

    this.connection.on('ready', ()=>{
      this.logMsg('ready');
      this.emit('ready', this);
    });
  }

	processMessage(data) {
		try{
			this.messenger.validate(data);
			let msg = this.messenger.unpack(data);
			this.emit('message', msg, this);
      this.emit(msg.service.type + ':' + msg.service.name, msg.service, msg.payload, this.connection.getSocket());
      //routing
      this.selectRoute(msg);
		}catch(e){
			this.logError(e, e.details);
      <% if (env === 'node'){ %>
      if(e.message === CONST.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID){
				this.informClientAboutExperiedToken();
			}
      <% } %>
		}
	}

  selectRoute(msg){
		switch(msg.service.type){
		//couple of special types
		case CONST.MSG_TYPE.RESPONSE: this.routeResponse(msg);  break;
		case CONST.MSG_TYPE.REQUEST: 	this.routeRequest(msg);  break;
		case CONST.MSG_TYPE.EVENT:    this.routeEvent(msg);     break;
			//all other
		default:                      this.routeCommon(msg);
		}
	}

	routeResponse(msg){
		let request = this.fullfillRequest(msg.service.id);
		if(request !== null){
			request.cb(msg);
		}
	}

	routeEvent(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.catch((e)=>{
				this.logError(e);
			});
	}

	routeCommon(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.catch((e)=>{
				this.logError(e);
				this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
			});
	}

	routeRequest(msg){
		this.router.route(msg.service, msg.payload, this.connection.getSocket())
			.then((responseData)=>{
				this.respond(responseData, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name});
			})
			.catch((e)=>{
				this.logError(e);
				this.respond({}, {id: msg.service.id, type: CONST.MSG_TYPE.RESPONSE, name: msg.service.name}, e);
			});
	}

	suicide() {
		this.emit('errored', this);
	}

	disconnect() {
		this.connection.disconnect();
	}

  terminate() {
		this.connection.terminate();
	}

	isDead() {
		return !this.connection.isAlive();
	}

  isAlive() {
		return this.connection.isAlive();
	}

	reconnect() {
		this.connection.reconnect();
	}

	isConnected(secure = true) {
		return this.connection(secure);
	}
<%- include('./client.common.requests.ejs'); %>

	getCredentials() {
		return this.options.credentials;
	}

	setCredentials(val = null) {
		this.options.credentials = val;
		this.emit('credentialsUpdate', val);
		return this;
	}

	credentialsIsValid(){
		return new Promise((resolve, reject)=>{
			let cred = this.getCredentials();
			JWT.verify(cred, this.options.credentials.key, (err, decoded)=>{
				if(err){
					reject(err);
				}else{
					if(typeof decoded !== 'undefined'){
						resolve(true);
					}else{
						reject(new Error('Decoded token is undefined'));
					}
				}
			});
		});
	}

	onAfterValidation(err, decoded){
		if(err){
			return false;
		}else if(typeof decoded !== 'undefined' && decoded !== null){
			return true;
		}else{
			return false;
		}
	}

  renewToken(){}

  connect(){}

	respond(resp, service = {}, error){
		if(typeof resp === 'object' && resp !== null){
			let msg = this.messenger.pack(resp, service, error);
			return this.connection.send(msg);
		}else{
			return true;
		}
	}

	__request(name, payload, cb, secure = true) {
		let message = this.messenger.pack(payload, {
			type: CONST.MSG_TYPE.REQUEST,
			timeOffset: this.timeOffset,
			name,
		});
		this.addRequest(this.messenger.getServiceData(message).id, cb);
		this.connection.send(message, secure).catch(this.logError.bind(this));
	}

	request(name, payload, secure = true) {
		return new Promise((resolve, reject) => {
			try {
				this.__request(name, payload, (response) => {
					if (response === CONST.ERR_MSG.REQUEST_TIMEOUT_MESSAGE) {
						return reject(response);
					}
					if (this.messenger.validate(response)) {
						if (this.messenger.isErrored(response)) {
							return reject(response);
						}
					}
					resolve(response);
				}, secure);
			} catch (e) {
				reject(e);
			}
		});
	}

	/**
	*	Отправка данных определенного типа и названия
	*	@param {string}	type	тип данных
	*	@param {string}	name	название
	*	@param {object}	payload	данные
	*	@returns	{Promise}
	*/
	send(type, name, payload, secure = true){
		if(type === CONST.MSG_TYPE.REQUEST){
			return this.request(name, payload,secure);
		}else{
			return this.message(type, name, payload,secure);
		}
	}

	message(type, name, payload, secure = true){
		let message = this.messenger.pack(payload, {
			type,
			timeOffset: this.timeOffset,
			name,
		});
		return this.connection.send(message, secure).catch(this.logError.bind(this));
	}

	informClientAboutExperiedToken(){
		this.logMsg('force to update token');
		this.send('__service', 'updateToken', {}, false).catch(this.logError.bind(this));
	}

  /**
  * Server time
  */
  requestServerTime() {
    if (this.connection.isConnected()) {
      const sendTime = Date.now();
      this.request('getTime', {}, true)
        .then((result)=>{
          const receiveTime = Date.now();
          const correction = Math.round((receiveTime - sendTime) / 2);
          const serverTime = parseInt(result, 10);
          const correctedTime = serverTime + correction;
          const offset = correctedTime - receiveTime;
          this.timeOffset = offset;
        })
        .catch((err)=>{
          this.logError(err);
        });
    }
  }

  set timeOffset(val) {
    this._timeOffset = val;
  }

  get timeOffset() {
    return this._timeOffset;
  }

  getTimeOnAuthorized(){
    if (this.getTimeOffsetInt) {
      clearInterval(this.getTimeOffsetInt);
      this.getTimeOffsetInt = null;
    }
    this.requestServerTime();
    this.getTimeOffsetInt = setInterval(this.requestServerTime.bind(this), CONST.TIME_OFFSET_REQUEST_INTERVAL);
  }
}

module.exports = notWSServerClient;
