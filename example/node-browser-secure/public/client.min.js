var notWSClient=function(){"use strict";let e={1e3:"Normal Closure",1001:"Going Away",1002:"Protocol Error",1003:"Unsupported Data",1005:"No Status Recvd",1006:"Abnormal Closure",1007:"Invalid frame payload data",1008:"Policy Violation",1009:"Message too big",1010:"Missing Extension",1011:"Internal Error",1012:"Service Restart",1013:"Try Again Later",1014:"Bad Gateway",1015:"TLS Handshake"};const t=Symbol("activity"),s=Symbol("state");var i={STATE:{NOT_CONNECTED:0,CONNECTED:1,AUTHORIZED:2,NO_PING:3,ERRORED:4},STATE_NAME:{0:"Не подключен",1:"Подключен",2:"Авторизован",3:"Нет отклика",4:"Ошибка связи"},ACTIVITY:{IDLE:0,CONNECTING:1,CLOSING:2,TERMINATING:3,AUTHORIZING:4},ACTIVITY_NAME:{0:"Простаивает",1:"Открытие связи",2:"Закрытие связи",3:"Обрыв связи",4:"Авторизация"},WS_CLOSURE_REASONS:e,mapWsCloseCodes:function(t){if(!t)return"unknown reason";if(t.reason)return t.reason;let s=void 0!==t.code?t.code.toString():"undefined";return isNaN(parseInt(t))||(s=t),Object.prototype.hasOwnProperty.call(e,s)?e[s]:`Unknown reason: ${s}`},HEARTBEAT_INTERVAL:3e4,SYMBOL_ACTIVITY:t,SYMBOL_STATE:s,DEFAULT_SERVER_NAME:"not-ws server",DEFAULT_CLIENT_NAME:"not-ws link",ERR_MSG:{REQUEST_TIMEOUT:"Request timeout",MSG_ID_IS_NOT_VALID:"Message ID is not valid uuidv4",MSG_CREDENTIALS_IS_NOT_VALID:"Message Credentials is not valid!",MSG_TYPE_IS_NOT_VALID:"Message Type is not valid!",MSG_NAME_IS_NOT_VALID:"Message Name is not valid!"},PING_TIMEOUT:3e4,CLIENT_RECONNECT_TIMEOUT:5e3,CLIENT_RECONNECT_TIMEOUT_LONG:3e4,CLIENT_AUTO_RECONNECT:!0,heartbeat:function(){this.isAlive=!0},noop:function(){},MSG_TYPE:{REQUEST:"request",RESPONSE:"response",EVENT:"event",COMMAND:"command"},TOKEN_TTL:1800};const r=(new Date).getTimezoneOffset()/60*-1;let[,o]=location.hash.split("#");const n=o,h="development",a=()=>{};function c(e){return e<10?"0"+e:e}function u(e){return(e=e||new Date).getFullYear()+"-"+c(e.getMonth()+1)+"-"+c(e.getDate())+"T"+c(e.getHours())+":"+c(e.getMinutes())+":"+c(e.getSeconds())}let l=e=>(function(){let t=u();console.log(`[${t}]: ${e}::`,...arguments)});var g={TZ_OFFSET:r,logMsg:function(){let e=u();console.log(`[${e}]: `,...arguments)},logError:function(){let e=u();console.error(`[${e}]: `,...arguments)},genLogMsg:l,genLogError:e=>(function(){let t=u();console.error(`[${t}]: ${e}::`,...arguments)}),genLogDebug:e=>n===h?l(e):a,isFunc:function(e){return"function"==typeof e},isArray:function(e){return"object"==typeof e&&e instanceof Array},localIsoDate:u,tryParseJSON:function(e){try{let t=JSON.parse(e);if(t&&"object"==typeof t)return t}catch(e){console.error(e)}return!1},capitalizeFirstLetter:function(e){return e.charAt(0).toUpperCase()+e.slice(1)}};class d extends EventEmitter{constructor(e,t={},s){return super(),this.options=e,this.__name="notWSRouter",this.logMsg=s?s.log:g.genLogMsg(this.__name),this.logDebug=s?s.debug:g.genLogDebug(this.__name),this.logError=s?s.error:g.genLogError(this.__name),this.routes={__service:{updateToken:()=>{this.emit("updateToken")}}},t&&Object.keys(t).length>0&&this.initRoutes(t),this}initRoutes(e){for(let t in e)this.setRoutesForType(t,e[t])}route({type:e,name:t,cred:s},i,r){if(Object.prototype.hasOwnProperty.call(this.routes,e)&&Object.prototype.hasOwnProperty.call(this.routes[e],t))return this.logMsg(r.ip,e,t),this.routes[e][t](i,s,r);throw new Error(`Route not found ${e}/${t}`)}setRoutesForType(e,t){return this.validateType(e),this.validateRoutes(t),Object.prototype.hasOwnProperty.call(this.routes,e)?this.routes[e]=Object.assign(this.routes[e],t):this.routes[e]=t,this}unsetRoutesForType(e,t=[]){if(this.validateType(e),this.validateRoutesList(t),Object.prototype.hasOwnProperty.call(this.routes,e)){for(let s of t)Object.prototype.hasOwnProperty.call(this.routes[e],s)&&delete this.routes[e][s];0===Object.keys(this.routes[e]).length&&delete this.routes[e]}return this}validateType(e){if("string"!=typeof e||""===e)throw new Error("Route's type name should be a String!");return!0}validateRoutes(e){if("object"!=typeof e||null==e)throw new Error("Route's type's routes set should be an Object!");return!0}validateRoutesList(e){if(!Array.isArray(e)||void 0===e)throw new Error("List of routes names should be an Array!");return!0}}for(var p=[],T=0;T<256;++T)p[T]=(T+256).toString(16).substr(1);var E,y="undefined"!=typeof crypto&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues.bind(msCrypto);if(y){var f=new Uint8Array(16);E=function(){return y(f),f}}else{var m=new Array(16);E=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),m[t]=e>>>((3&t)<<3)&255;return m}}function _(e,t,s){var i=t&&s||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var r=(e=e||{}).random||(e.rng||E)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t)for(var o=0;o<16;++o)t[i+o]=r[o];return t||function(e,t){var s=t||0,i=p;return i[e[s++]]+i[e[s++]]+i[e[s++]]+i[e[s++]]+"-"+i[e[s++]]+i[e[s++]]+"-"+i[e[s++]]+i[e[s++]]+"-"+i[e[s++]]+i[e[s++]]+"-"+i[e[s++]]+i[e[s++]]+i[e[s++]]+i[e[s++]]+i[e[s++]]+i[e[s++]]}(r)}const R={secure:!1,securityException:["request.auth"],validators:{},types:{typeOfMessage:["list","of","name's","of","actions"],test:["sayHello"],__service:["updateToken"]}};class S extends EventEmitter{constructor(e={}){return super(),this.options=Object.assign({},R,e),this}setCredentials(e){return this.options.credentials=e,this}getServiceData(e){return{id:e.id,time:e.time,type:e.type,name:e.name}}getType(e){return e.type}getName(e){return e.name}getCredentials(e){return e.cred}getPayload(e){return e.payload}isErrored(e){return void 0!==e.error&&null!==e.error}getErrorMessage(e){if("string"==typeof e.error)return e.error;if("object"==typeof e.error)return`${e.error.code}: ${e.error.message}`;throw new Error("No error data in message")}getErrorReport(e){return e.error}pack(e,t,s){if(null==t)throw new Error("No Service Data for packing notWSMsg");let i={id:_(),time:(new Date).getTime(),payload:e};return this.options.credentials&&(i.cred=this.options.credentials),s&&(i.error=s),Object.assign(i,t)}unpack(e){if(this.isErrored(e)){let t=new Error(this.getErrorMessage(e));throw t.report=this.getErrorReport(e),t}return{cred:this.getCredentials(e),service:this.getServiceData(e),payload:this.getPayload(e)}}validateCredentials(e={}){return this.options.validators&&this.options.validators.credentials?this.options.validators.credentials(e):!this.options.secure}validateType(e){return!!this.options.types&&Object.keys(this.options.types).indexOf(e)>-1}validateTypeAndName(e,t){return!(!this.options.types||!Object.prototype.hasOwnProperty.call(this.options.types,e))&&this.options.types[e].indexOf(t)>-1}routeIsSecurityException(e,t){let s=`${e}.${t}`;return!(!this.options.securityException||!Array.isArray(this.options.securityException))&&this.options.securityException.indexOf(s)>-1}validate(e){let t=this.getServiceData(e);if(!validator.isUUID(t.id,4))throw new Error(i.ERR_MSG.MSG_ID_IS_NOT_VALID);if(!this.routeIsSecurityException(t.type,t.name)&&!this.validateCredentials(this.getCredentials(e)))throw new Error(i.ERR_MSG.MSG_CREDENTIALS_IS_NOT_VALID);if(!this.validateType(this.getType(e)))throw new Error(i.ERR_MSG.MSG_TYPE_IS_NOT_VALID);if(!this.validateTypeAndName(this.getType(e),this.getName(e)))throw new Error(i.ERR_MSG.MSG_NAME_IS_NOT_VALID);return e}}class v extends EventEmitter{constructor({options:e,messenger:t,router:s}){super();let i=e.logger;this.options=e,this.ws=null,this.connCount=0,this.connCountMax=10,this.errConnMsg=null,this.firstConn=!0,this.messenger=t||new S,this.router=s||new d,this.router.on("updateToken",()=>{this.renewToken.bind(this)}),this.jwtToken=null,this.jwtExpire=null,this.jwtDate=null,this.logMsg=i?i.log:g.genLogMsg(this.__name),this.logDebug=i?i.debug:g.genLogDebug(this.__name),this.logError=i?i.error:g.genLogError(this.__name),this.requests=[],this.reqTimeout=15e3,this.reqChkTimer=null,this.reqChkStep=2e3,window.onunload=this.disconnect.bind(this),window.onbeforeunload=this.disconnect.bind(this),this.connect()}disconnect(){this.logMsg("Отключение от сервера..."),this.ws?(this.ws.onclose=function(){},this.ws.close(),this.stopReqChckTimer()):console.trace()}getToken(e=!1){let t=localStorage.getItem("token");return void 0!==t&&t&&!e?Promise.resolve(t):g.isFunc(this.options.getToken)?this.options.getToken():Promise.reject()}async renewToken(){try{let e=await this.getToken(!0);if(!e)throw new Error("Token isn't renewed");this.saveToken(e)}catch(e){this.logError(e)}}saveToken(e){localStorage.setItem("token",e),this.jwtToken=e,this.messenger.setCredentials(e)}startReqChckTimer(){clearTimeout(this.reqChkTimer),this.reqChkTimer=setTimeout(this.checkRequests.bind(this),this.reqChkStep)}stopReqChckTimer(){clearTimeout(this.reqChkTimer)}findRequest(e){for(let t=0;t<this.requests.length;t++)if(this.requests[t].id===e)return t;return!1}extortRequest(e){let t=this.findRequest(e);if(!1===t)return void this.logMsg(`failed to find request for response ${e}`);let s=this.requests[t];return this.requests.splice(t,1),g.isFunc(s.cb)?s:null}addRequest(e,t){this.requests.push({id:e,time:Date.now(),cb:t})}checkRequests(){let e=[],t=Date.now();this.requests.forEach(s=>{t-s.time>this.reqTimeout&&e.push(s.id)}),e.forEach(e=>{let t=this.findRequest(e);if(!1===t)return void this.logMsg(`timeout check:failed to find request for response ${e}`);let s=this.requests[t];g.isFunc(s.cb)?s.cb(i.ERR_MSG.REQUEST_TIMEOUT):this.logMsg(`timeout check:Не задан callback для запроса с id: ${e}`),this.requests.splice(t,1)})}onMessage(e){try{if(this.logDebug(e),this.checkPingMsg(e))return;let t=g.tryParseJSON(e.data);if(!t)return void this.logMsg(`получено сообщение от сервера:${e.data}`);this.messenger.validate(t);let s=this.messenger.unpack(t);this.router.route(s.service,s.payload,this.ws).then(this.respond.bind(this)).catch(this.logError.bind(this))}catch(e){this.logError(e)}}async connect(){try{this.ws&&this.ws.readyState!==WebSocket.CLOSED&&this.disconnect(),this.isAlive=!0,this.logMsg("Подключение к WebSocket серверу..."),this.connCount++,this.isSecure()&&this.saveToken(await this.getToken());let e=this.getConnectURI();this.logMsg("Connecting to: ",e),this.ws=new WebSocket(e),this.ws.onopen=this.onOpen.bind(this),this.ws.error=this.onError.bind(this)}catch(e){this.logError(e),this.scheduleReconnect()}}onOpen(){this.logMsg("Установлено подключение к WebSocket серверу."),this.connCount=0,this.isAlive=!0,clearInterval(this.connectTimeout),this.connectTimeout=!1,this.errConnMsg=null,this.ws.onmessage=this.onMessage.bind(this),this.ws.onclose=this.onClose.bind(this),this.startReqChckTimer(),this.initPing(),this.emit("ready")}onError(e){this.connectTimeout&&(clearInterval(this.connectTimeout),this.connectTimeout=!1),this.logError(e),this.scheduleReconnect()}onClose(e){let t=`${e.code}::`+i.mapWsCloseCodes(e);this.logMsg(`подключение разорвано: ${t}`),this.isAutoReconnect()&&this.scheduleReconnect(),this.stopReqChckTimer()}getConnectURI(){let e=`ws://${this.options.host}:${this.options.port}/${this.options.path}`;return this.isSecure()?`${e}?token=${this.jwtToken}`:e}getReconnectTimeout(){return this.connCount>=this.connCountMax?i.CLIENT_RECONNECT_TIMEOUT_LONG:i.CLIENT_RECONNECT_TIMEOUT}scheduleReconnect(){let e=this.getReconnectTimeout();this.logMsg(`Планируем переподключение каждые ${e}мс`),this.connectTimeout=setInterval(()=>{!1===this.isAlive&&this.ws.readyState===this.ws.CLOSED&&this.connect()},e)}isSecure(){return this.options.secure}isAutoReconnect(){return void 0!==this.options.autoReconnect?this.options.autoReconnect:i.CLIENT_AUTO_RECONNECT}initPing(){this.options.ping&&(this.intPing&&(clearInterval(this.intPing),this.intPing=!1),this.intPing=setInterval(this.sendPing.bind(this),this.options.pingTimeout||i.PING_TIMEOUT))}sendPing(){if(this.logDebug("out ping",this.isAlive),!1===this.isAlive)return this.logMsg("Connection is not alive (no pong). Terminating"),this.disconnect(),void this.scheduleReconnect();this.isAlive=!1,this.ws.send("ping")}checkPingMsg(e){return"pong"===e.data&&(this.logDebug("in pong"),this.isAlive=!0,!0)}respond(e,t={},s){if("object"==typeof e&&null!==e){let i=this.options.messenger.pack(e,t,s);return this.sendMsg(i)}return!0}isConnected(){return this.ws&&this.isAlive}sendMsg(e){return new Promise((t,s)=>{try{this.isConnected()?(console.log("send message",e),this.ws.send(JSON.stringify(e),e=>{e?(this.state=i.STATE.ERRORED,s(e)):t()})):(this.logDebug("Failed to send message to ws client, connection is in state: "+i.STATE_NAME[this.state]+"!"),t())}catch(e){this.state=i.STATE.ERRORED,s(e)}})}send(e,t,s){return e===i.MSG_TYPE.REQUEST?this.sendRequest(t,s):this.sendMessage(e,t,s)}sendMessage(e,t,s){this.logDebug("message",e,t,s);let i=this.messenger.pack(s,{type:e,timeOffset:this.timeOffset,name:t});return this.sendMsg(i).catch(this.logError.bind(this))}sendRequest(e,t){return this.logDebug("request",e,t),new Promise((s,i)=>{try{let i=this.messenger.pack(t,{type:"request",timeOffset:this.timeOffset,name:e});this.addRequest(this.messenger.getServiceData(i).id,s),this.ws.send(JSON.stringify(i))}catch(e){this.logError(e),i(e)}})}}return v}();
